# 系列三導讀：格式分類與學習地圖

## 🎯 本系列的學習目標

當你學完系列二的密碼學演算法（ECC、ECDSA、數位簽章）後，下一個問題是：

> **這些演算法產生的資料，如何儲存和傳輸？**

你會遇到各種陌生的術語：

- 📦 **CBOR**：二進位資料序列化格式
- 🪪 **X.509**：數位憑證的標準格式
- 🔤 **ASN.1**：定義資料結構的語言
- 🔐 **DER/PEM**：編碼規則
- 🔑 **X9.62**：橢圓曲線公鑰的表示格式
- 📜 **PKCS#7**：簽章資料容器
- 🎫 **JWT**：Web token 格式

**本系列目標**：讓你理解這些格式的**分類、關係、用途**，而不被術語淹沒。

---

## 🧩 核心概念：從蓋房子到數位憑證

### 用蓋房子的比喻理解格式分層

當你第一次看到 **ASN.1、DER、X.509、CBOR** 這些術語時，就像看到一堆建築材料散落在地上：你可能認得哪塊是磚頭（ECC）、哪條是鋼筋（ECDSA），但很難想像它們如何構成一棟堅固的建築（一個安全的數位憑證）。

讓我們用蓋房子的比喻來理解。要蓋一棟房子，你需要：

1. **物理定律（數學基礎）**
   如重力、材料力學。這是蓋房子的根本，如同 **ECC** 和 **ECDSA** 是數位簽章的數學基石。

2. **建築藍圖（資料結構）**
   定義了房子的格局，哪裡是客廳、哪裡是臥室。這就像 **ASN.1**，它是一種語言，用來描繪數位憑證（**X.509**）或簽章容器（**PKCS#7**）的內部結構。

3. **施工規範（編碼規則）**
   告訴工人如何將藍圖上的設計變成實際的建築結構。**DER** 就是這樣一種嚴格的施工規範，它將抽象的結構轉換成標準的二進位格式。

4. **標準化建材（特定格式）**
   比如預鑄的窗戶或門，有特定的尺寸和規格。**X9.62** 就是 ECC 公鑰的標準規格。

5. **另一套現代化工法（新的資料格式）**
   除了傳統的鋼筋水泥（ASN.1/DER），現在也有更現代的組合屋工法。**CBOR** 就是這樣一種更現代、更簡潔的資料格式。

---
---

## 🗺️ 格式關係全景圖

### 一、概念分層與職責

```
🔢 數學演算法層（系列二已學）
└── ECC/ECDSA
    ├── 橢圓曲線密碼學原理
    ├── 私鑰生成公鑰
    └── ECDSA 數位簽章

🔤 資料表示層（如何變成二進位）
├── ASN.1（抽象語法標記）
│   └── 定義資料結構的語言
│
├── DER（可分辨編碼規則）
│   └── ASN.1 的嚴格二進位編碼
│   └── X.509、PKCS#7 使用
│
├── CBOR（簡明二進位物件表示法）
│   └── 現代二進位序列化格式
│   └── WebAuthn 使用
│
└── X9.62（橢圓曲線點格式）
    └── ECC 公鑰點的 raw 二進位表示（0x04||X||Y）
    └── 需包裝成 SPKI 才是完整公鑰格式

📦 標準容器層（組織多個元素）
├── X.509（數位憑證）
│   └── 包含：公鑰 + 持有者資訊 + CA 簽章
│   └── 編碼：使用 ASN.1/DER
│
├── PKCS#7（簽章資料容器）
│   └── 包含：資料 + 簽章 + 憑證鏈
│   └── 編碼：使用 ASN.1/DER
│
├── Attestation Object（裝置證明）
│   └── 包含：憑證鏈 + 驗證資料
│   └── 編碼：使用 CBOR
│
└── JWT（Web token）
    └── 包含：Header + Payload + Signature
    └── 編碼：JSON + Base64URL

🚚 傳輸編碼層（文字編碼）
├── PEM
│   └── DER 的 Base64 編碼 + BEGIN/END 標記
│   └── 方便文字傳輸和儲存
│
└── Base64URL
    └── URL 安全的 Base64 變體
    └── JWT 使用
```

### 二、關鍵理解

**1. 區分「語言」與「編碼」**
- **ASN.1** 是語言（定義結構）
- **DER** 是編碼規則（如何變成二進位）
- **PEM** 是傳輸格式（DER 的 Base64）

**2. 區分「編碼方式」與「容器」**
- **CBOR、ASN.1/DER** 是編碼/序列化方式（類似 JSON）
- **X.509、PKCS#7、JWT** 是容器（組織多個元素）

**3. 理解格式選擇的權衡**
- **ASN.1/DER**：傳統、密碼學標準、廣泛支援
- **CBOR**：現代、緊湊、易解析
- **JWT**：Web 友善、人類可讀、URL 安全
---

## 📚 系列三文章架構

### 第 9 篇：資料序列化與 CBOR

**學習重點**：
- 什麼是資料序列化？（類似 JSON 的概念）
- CBOR 的設計理念：緊湊、二進位、易解析
- 與 JSON、Protocol Buffers 的比較

**為什麼重要**：
- 理解現代二進位格式的設計思想
- 對比 ASN.1/DER（傳統）與 CBOR（現代）
- WebAuthn、App Attest 等新協定都用 CBOR

**核心概念**：
```
資料序列化 = 將結構化資料轉成可儲存/傳輸的格式

JSON   → 文字格式（人類可讀，但較大）
CBOR   → 二進位格式（緊湊、高效）
ASN.1  → 二進位格式（傳統、廣泛支援）
```

---

### 第 10 篇：X.509 憑證格式

**學習重點**：
- X.509 憑證的三層結構（TBS、簽章演算法、簽章值）
- 憑證本體（tbsCertificate）的關鍵欄位
- 憑證鏈的信任模型

**為什麼重要**：
- X.509 是數位憑證的**全球標準**
- 理解 HTTPS、程式碼簽章、裝置證明的基礎
- 連結系列二的「公鑰基礎建設（PKI）」概念

**核心概念**：
```
X.509 憑證 = 公鑰 + 持有者資訊 + CA 簽章

憑證鏈：
Root CA（自簽）
  └─ Intermediate CA（Root 簽章）
      └─ End-Entity Cert（Intermediate 簽章）

信任模型：信任 Root CA → 信任整條鏈
```

---

### 第 11 篇：ASN.1 與編碼格式

**學習重點**：
- 為什麼 X.509 憑證看起來像「亂碼」？
- ASN.1 是什麼？（抽象語法標記）
- DER、BER、PEM 的差異與用途

**為什麼重要**：
- ASN.1 是密碼學領域的「通用語言」
- 理解為什麼憑證、PKCS#7 都用 ASN.1
- 掌握 DER ↔ PEM 的轉換邏輯

**核心概念**：
```
ASN.1 = 定義資料結構的語言（藍圖）
DER   = ASN.1 的嚴格二進位編碼規則（施工規範）
PEM   = DER 的 Base64 文字編碼（方便傳輸）

關係：
ASN.1（抽象） → DER（二進位） → PEM（文字）
```

---

### 第 12 篇：X9.62 橢圓曲線公鑰格式

**學習重點**：
- X9.62 標準的橢圓曲線點編碼
- 未壓縮格式（0x04 || X || Y）與壓縮格式
- 與 SPKI（SubjectPublicKeyInfo）的關係

**為什麼重要**：
- 連結系列二的 ECC 數學與實際格式
- 理解「公鑰點」如何表示成二進位
- 掌握公鑰格式轉換（X9.62 ↔ SPKI）

**核心概念**：
```
ECC 公鑰 = 橢圓曲線上的一個點 (X, Y)

X9.62 未壓縮格式：
0x04 || X (32 bytes) || Y (32 bytes)

為什麼需要轉換成 SPKI？
→ X9.62 只是「點」的表示
→ SPKI 包含「曲線參數 + 點」，是完整的公鑰格式
```

---

### 第 13 篇：PKCS#7 - 簽章資料容器

**學習重點**：
- PKCS#7 的用途：打包「資料 + 簽章 + 憑證」
- SignedData 結構的設計理念
- 與 CMS（Cryptographic Message Syntax）的關係

**為什麼重要**：
- PKCS#7 是簽章資料的**標準容器**
- 理解「分離簽章」與「附加簽章」的差異
- 廣泛應用於文件簽章、程式碼簽章

**核心概念**：
```
PKCS#7 SignedData = 資料 + 簽章 + 憑證鏈

用途：
1. 打包所有驗證所需的資訊
2. 接收方可以獨立驗證（不需額外取得憑證）
3. 支援多個簽章者
```

---

### 第 14 篇：JWT 與 JWS 格式解析

**學習重點**：
- JWT 的三段式結構：Header.Payload.Signature
- Base64URL 編碼的設計理念
- 與傳統格式（ASN.1/DER）的差異

**為什麼重要**：
- JWT 是 Web API 認證的**事實標準**
- 理解「Web 友善」格式的設計權衡
- 對比傳統密碼學格式與現代 Web 格式

**核心概念**：
```
JWT = Header.Payload.Signature（都是 Base64URL 編碼）

設計特點：
✓ URL 安全（可以放在 URL 參數）
✓ 人類可讀（Base64 可以解碼查看）
✓ 無狀態（self-contained）

vs. ASN.1/DER：
→ JWT：現代、Web 友善、易除錯
→ ASN.1：傳統、緊湊、密碼學標準
```

---

### 第 15 篇：WebAuthn 與裝置信任模型

**學習重點**：
- WebAuthn 標準的設計理念
- Attestation Object 的結構
- Authenticator Data 的用途

**為什麼重要**：
- 理解現代裝置證明的標準
- 整合前面所有格式知識（CBOR + X.509 + ...）
- 連結到實務應用（系列四）

**核心概念**：
```
WebAuthn Attestation Object（CBOR 編碼）：
{
  fmt: "格式識別符",
  attStmt: {
    x5c: [憑證鏈],  ← X.509（DER 編碼）
    ...
  },
  authData: <二進位>
}

混合格式設計：
→ 最外層：CBOR（現代、高效）
→ 憑證鏈：X.509（標準、相容）
```

---

### 第 16 篇：完整實例解析

**學習重點**：
- 整合前面所有格式知識
- 完整解析一個真實的 attestation object
- 格式之間的轉換流程

**為什麼重要**：
- 驗證學習成果
- 理解格式如何在真實場景中協同運作
- 為系列四的實作打基礎


---



## 📖 歷史演進：為什麼有這麼多格式？

```
時間軸與技術演進：

1988 ─ ASN.1 標準發布
  │    └─ 定義通用資料結構語言
  │
1990s ─ X.509、PKCS#7 發布
  │     └─ 使用 ASN.1/DER 編碼
  │     └─ 成為密碼學基礎設施標準
  │
2000s ─ Web 應用興起
  │     └─ Base64、JSON 成為主流
  │
2013 ─ CBOR RFC 發布
  │    └─ 現代化的二進位格式
  │    └─ 彌補 JSON（文字）與 ASN.1（複雜）之間的空白
  │
2015 ─ JWT 成為 RFC 標準
  │    └─ Web API 認證標準
  │    └─ 人類可讀、URL 安全
  │
2019 ─ WebAuthn 成為 W3C 標準
       └─ 混合使用：CBOR（外層）+ X.509（憑證）
       └─ 兼顧現代性與相容性
```

**設計權衡**：
- **ASN.1/DER**：歷史悠久、廣泛支援、密碼學標準
- **CBOR**：現代設計、效率高、易解析
- **JWT**：Web 友善、人類可讀、易除錯

**為什麼新協定還要用舊格式？**
- X.509 憑證是全球基礎設施（根憑證、CA 體系）
- PKCS#7 是簽章資料的成熟標準
- 新協定（WebAuthn）選擇：外層用 CBOR（現代），憑證用 X.509（相容）

---

## 🎓 學習路徑建議

### 路徑 A：從零開始（建議初學者）

**順序**：
1. 第 9 篇（CBOR）→ 理解現代序列化
2. 第 10 篇（X.509）→ 理解憑證結構
3. 第 11 篇（ASN.1）→ 理解為什麼是「亂碼」
4. 第 12 篇（X9.62）→ 連結 ECC 與格式
5. 第 13 篇（PKCS#7）→ 理解簽章容器
6. 第 14 篇（JWT）→ 理解現代 Web 格式
7. 第 15 篇（WebAuthn）→ 理解混合設計
8. 第 16 篇（實例）→ 整合所有知識

**理由**：
- 先學簡單的（CBOR）再學複雜的（ASN.1）
- 循序漸進，理解格式演進的邏輯

---

### 路徑 B：已有基礎知識（快速上手）

**順序**：
1. 本篇（導讀）→ 理解格式分類
2. 第 16 篇（實例）→ 看完整解析
3. 遇到不懂的格式 → 回頭查第 9-15 篇

**理由**：
- 先看全景圖
- 直接看實例
- 按需學習

---

### 路徑 C：特定問題導向

| 問題 | 推薦閱讀 |
|------|---------|
| 什麼是資料序列化？ | 第 9 篇（CBOR）|
| 憑證裡有什麼欄位？ | 第 10 篇（X.509）|
| 為什麼憑證是亂碼？ | 第 11 篇（ASN.1）|
| ECC 公鑰如何儲存？ | 第 12 篇（X9.62）|
| 如何打包簽章資料？ | 第 13 篇（PKCS#7）|
| JWT 是什麼格式？ | 第 14 篇（JWT）|
| WebAuthn 用了哪些格式？ | 第 15 篇（WebAuthn）|
| 看完整範例 | 第 16 篇（實例）|

---

## 🔗 與其他系列的關聯

### 系列一：API 安全背景與驗證框架

**關聯**：
- 系列一解釋「為什麼需要這些機制」
- 系列三解釋「這些機制用了哪些格式」

**閱讀建議**：
- 先讀系列一理解動機
- 再讀系列三理解技術細節

---

### 系列二：密碼學演算法基礎

**關聯**：
- 系列二解釋「數學原理」（ECC、ECDSA、數位簽章）
- 系列三解釋「資料格式」（公鑰、簽章如何儲存）

**閱讀建議**：
- **必須先讀系列二**，否則無法理解格式的用途
- 系列二 + 系列三 = 完整的密碼學基礎知識

**具體連結**：
| 系列二概念 | 系列三格式 | 關係 |
|-----------|-----------|------|
| ECC 公鑰點 (X, Y) | X9.62 格式 | 如何表示成二進位 |
| ECDSA 簽章 (r, s) | ASN.1 SEQUENCE | 如何編碼 |
| 公鑰基礎建設（PKI） | X.509 憑證鏈 | 如何實現信任鏈 |
| 數位簽章驗證 | PKCS#7 容器 | 如何打包驗證所需資訊 |

---

### 系列四：實務應用

**關聯**：
- 系列三提供格式知識
- 系列四展示如何在實際專案中應用

**閱讀建議**：
- 先讀系列三掌握格式
- 再讀系列四理解完整實作流程

---

## 🎯 學習成果檢驗

完成本系列後，你應該能夠：

**基礎理解**：
- ✅ 區分「語言」（ASN.1）、「編碼」（DER）、「容器」（X.509）
- ✅ 理解為什麼憑證看起來是「亂碼」
- ✅ 知道 CBOR vs ASN.1/DER 的差異與用途
- ✅ 理解 PEM 與 DER 的關係

**格式操作**：
- ✅ 知道如何將 DER 轉換成 PEM
- ✅ 理解 X9.62 公鑰如何包裝成 SPKI
- ✅ 知道如何解析 X.509 憑證
- ✅ 理解 JWT 的結構與驗證

**系統思維**：
- ✅ 理解格式的歷史演進與設計權衡
- ✅ 知道為什麼需要這麼多格式
- ✅ 能夠選擇適合的格式解決問題
- ✅ 為系列四的實作打下堅實基礎

---

## 💡 學習建議

### 1. 不要死記硬背

**❌ 錯誤方法**：
- 試圖記住所有格式的細節
- 死記 ASN.1 的 Tag 編號

**✅ 正確方法**：
- 理解格式的**分類與關係**
- 知道**為什麼**需要這個格式
- 遇到問題時知道**查哪篇文章**

### 2. 連結系列二的知識

每學一個格式，問自己：
- 這個格式儲存/傳輸**什麼數學物件**？（系列二學過的）
- 為什麼需要用這個格式？
- 與其他格式有什麼關係？

### 3. 動手實驗

光看理論很難理解，建議：
- 用 `openssl` 工具查看憑證
- 用線上工具解析 ASN.1
- 自己編碼/解碼 CBOR
- 解析 JWT token

### 4. 保持全景視角

學習細節時，記得回來看這篇導讀的**格式關係全景圖**，避免迷失在細節中。

---

## 📝 本篇總結

### 核心觀念

1. **四層分類**：數學 → 資料表示 → 容器 → 傳輸
2. **格式關係**：ASN.1（語言）→ DER（編碼）→ PEM（傳輸）
3. **歷史演進**：舊格式（ASN.1）與新格式（CBOR、JWT）並存

### 下一步

- **初學者**：開始閱讀第 9 篇（CBOR）
- **有經驗者**：跳到第 16 篇（實例解析）
- **特定問題**：查看問題導向表格

---

**本系列持續更新中**，歡迎提供回饋和建議！
